[
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "ca7300e6-2c35-42e0-ac21-5c48f94d308c",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC001-Onboarding Completion with Balance Compass",
    "description": "Verify that users can complete the onboarding process including the Balance Compass assessment, and receive generated weekly micro-tasks based on relational balance inputs.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Complete onboarding Q&A step 1 by selecting feeling and energy level, then click Next Step.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Select mood tags on step 2 and click Complete Sync to submit onboarding responses.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[10]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify that micro-tasks are generated based on Balance Compass results by navigating to Tasks section.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert onboarding completes successfully with a summary screen by checking the page title and section\n        assert 'Leela OS - AI Relationship Companion' in page_title\n        assert 'Task Management' in section\n        assert 'Fair tasks, stronger relationship' in description\n        # Verify micro-tasks are generated based on Balance Compass results by checking tasks list and summary\n        assert task_summary['completed'] == 1\n        assert task_summary['pending'] == 2\n        assert task_summary['coins_earned'] == 150\n        assert len(tasks) == 3\n        # Check at least one task is pending and one is completed\n        assert any(task['status'] == 'pending' for task in tasks)\n        assert any(task['status'] == 'completed' for task in tasks)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757301962771889//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.891Z",
    "modified": "2025-09-08T03:26:02.966Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "550d80d3-390f-42f5-9a92-108a75732d80",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC002-Create First Offer within 24 Hours",
    "description": "Ensure that users can create their first micro-offer within 24 hours of completing onboarding and that the offer is saved and visible to partners.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Complete onboarding step 1 by clicking 'Next Step' button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Next Step' button to proceed with onboarding step 2.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Select moods and click 'Complete Sync' to finish onboarding including Balance Compass.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at the bottom right to start creating a new micro-offer.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down to find the Weekly Yagna Loop Plan stage or relevant section to create a micro-offer.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Locate and navigate to the Weekly Yagna Loop Plan stage to create a micro-offer.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click on the 'Tasks' tab at the bottom navigation to check if Weekly Yagna Loop Plan stage is accessible there.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Rituals' tab to check if the Weekly Yagna Loop Plan stage is accessible there.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at the bottom right to check if it allows creating a micro-offer or navigating to Weekly Yagna Loop Plan stage.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at the bottom right to open creation options again and look for micro-offer creation or Weekly Yagna Loop Plan navigation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Goals' tab to check if the Weekly Yagna Loop Plan stage or micro-offer creation is accessible there.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at the bottom right to open creation options and check if micro-offer creation or Weekly Yagna Loop Plan stage is accessible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Daily Sync' button (index 27) to check if it leads to Weekly Yagna Loop Plan stage or micro-offer creation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at the bottom right (index 27) to open creation options and check for micro-offer creation or Weekly Yagna Loop Plan stage.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: micro-offer creation or visibility could not be verified.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The user successfully completed onboarding including Balance Compass. However, the Weekly Yagna Loop Plan stage and micro-offer creation interface could not be found or accessed despite thorough navigation through the app's main tabs (Tasks, Rituals, Goals) and multiple attempts to use the '+' button and related options. The micro-offer creation functionality appears to be missing or inaccessible, preventing completion of the task to create and save a micro-offer visible to partners within 24 hours of onboarding. Further investigation or development support is needed to resolve this issue.\nBrowser Console Logs:\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=boRl9BY3zwQMC50eAAAI' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[WARNING] Image with src \"http://localhost:3000/images/couples/romantic-couple-1.svg\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js:15:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302398403086//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.897Z",
    "modified": "2025-09-08T03:33:18.583Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "011baa4d-6244-490c-9f6f-0ad7b42a9663",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC003-Daily 30-Second Sync Completion",
    "description": "Verify that users can complete the daily Home Hub 30-second sync including mood and energy check-ins and viewing partner/family updates.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click 'Next Step' to proceed with daily sync after confirming mood and energy input.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Next Step' button to proceed to step 2 of Daily Sync.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Complete Sync' button to finalize the daily sync and confirm completion.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the sync completion confirmation UI element is visible after completing the sync\n        frame = context.pages[-1]\n        sync_confirmation = frame.locator('text=Sync Completed')\n        assert await sync_confirmation.is_visible(), 'Sync completion confirmation is not visible'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/175730190384377//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.903Z",
    "modified": "2025-09-08T03:25:03.966Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "d5624bf0-1eed-4b01-bcc5-e2e07d81fd66",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC004-Weekly Plan → Do → Reflect Loop Engagement",
    "description": "Verify the full weekly Yagna Loop workflow: planning micro-offers Sunday night, tracking progress during the week, and reflecting on completion over the weekend.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to the Plan stage to create micro-offers for Sunday night.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: data consistency verification between Plan, Do, and Reflect stages could not be completed.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue of being stuck on Daily Sync step 1, preventing access to Plan stage and further workflow testing. Stopping as the task cannot proceed.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=_PdFvWvynKhczhnFAAAb' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=srgeJhCWdo_beilUAAAx' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0is66tl&sid=srgeJhCWdo_beilUAAAx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757301808422647//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.909Z",
    "modified": "2025-09-08T03:23:28.553Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "1573a18a-aa37-47af-a7c3-a823f4822f6c",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC005-Kids Dashboard Parent-led Modules Functionality",
    "description": "Verify that all six parent-led modules within the Kids Dashboard are functional including usage tracking and event logging.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on the 'Kids' navigation button to access the Kids Dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the button at index 23 to navigate to Kids Dashboard.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Identify and navigate to each of the six parent-led modules within the Kids Dashboard.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform a representative action in 'Today's Fun' module, such as adding a kind act, then verify usage tracking and event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div[2]/div[2]/div/div/div[6]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to the next parent-led module tab 'My Growth' and perform representative actions to verify functionality and logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform a representative action in 'My Growth' module, such as clicking 'See My Progress!' to verify functionality and event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div[3]/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to the next parent-led module tab 'Ask Leela' and perform representative actions to verify functionality and event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Perform a representative action in 'Ask Leela' by clicking the 'Understanding Feelings' button to verify functionality and event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div[4]/div/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to the next parent-led module tab 'My Stars' and perform representative actions to verify functionality and event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/main/div/div/div/div[2]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to the next parent-led module tab 'Rituals' or equivalent and perform representative actions to verify functionality and event logging.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Perform a representative action in the 'Rituals' module to verify functionality and event logging, then complete the test.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Repeat' button for 'Morning Connection' ritual to perform a representative action and verify event logging and UI update.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div[2]/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify that the ritual action is logged and usage tracked, then complete the task.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify that all actions across the six parent-led modules are logged and usage tracked, then complete the task.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the 'Kids Dashboard' page is loaded by checking the presence of the six parent-led modules tabs.\n        parent_led_modules = [\"Today's Fun\", \"My Growth\", \"Ask Leela\", \"My Stars\", \"Rituals\", \"Sacred Rituals\"]\n        for module_name in parent_led_modules:\n            module_tab = frame.locator(f\"text={module_name}\")\n            assert await module_tab.is_visible(), f\"Module tab '{module_name}' should be visible on Kids Dashboard.\"\n          \n        # Assert that actions performed in each module are reflected in the UI and event logs are triggered.\n        # Since the test plan involves clicking buttons and verifying usage tracking and event logging,\n        # we verify that after clicking, expected UI changes or log indicators appear.\n        # Example: Verify that after clicking 'Repeat' in 'Morning Connection' ritual, the streak or status updates.\n        morning_connection_status = frame.locator(\"xpath=//div[contains(text(),'Morning Connection') and contains(text(),'Mastered')]\")\n        assert await morning_connection_status.is_visible(), \"Morning Connection ritual status should be visible and updated after action.\"\n          \n        # Verify that the progress percentage in 'Sacred Rituals' section is displayed correctly.\n        progress_percentage = frame.locator(\"xpath=//div[contains(text(),'Sacred Rituals')]/following-sibling::div[contains(text(),'%')]\")\n        assert await progress_percentage.is_visible(), \"Progress percentage in Sacred Rituals should be visible.\"\n          \n        # Verify that the 'Repeat' button for 'Morning Connection' ritual is visible and clickable.\n        repeat_button = frame.locator(\"xpath=//button[contains(text(),'Repeat') and ancestor::div[contains(.,'Morning Connection')]]\")\n        assert await repeat_button.is_enabled(), \"Repeat button for Morning Connection ritual should be enabled.\"\n          \n        # Verify that the day streak and coins earned are displayed in the 'Sacred Rituals' section.\n        day_streak = frame.locator(\"xpath=//div[contains(text(),'Sacred Rituals')]/following-sibling::div[contains(text(),'day streak')]\")\n        coins_earned = frame.locator(\"xpath=//div[contains(text(),'Sacred Rituals')]/following-sibling::div[contains(text(),'coins earned')]\")\n        assert await day_streak.is_visible(), \"Day streak should be visible in Sacred Rituals section.\"\n        assert await coins_earned.is_visible(), \"Coins earned should be visible in Sacred Rituals section.\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302427700051//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.914Z",
    "modified": "2025-09-08T03:33:47.894Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "da4eff8c-23ec-4cee-8b60-170b6b2bf064",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC006-One-Tap Weekend Plan Generation and Acceptance",
    "description": "Ensure users can generate balanced weekend plans with one tap and that receiving users can accept or reject the proposed plan, with acceptance rate verified.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click the button to trigger One-Tap Weekend Planner to generate a weekend plan.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Try Now' button at index 15 to see if it triggers the One-Tap Weekend Planner.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[6]/div[2]/div[2]/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Send the current weekend plan to partner for acceptance.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the option to send the weekend plan to the partner for acceptance.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Expected result unknown, forcing failure.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The One-Tap Weekend Planner successfully generated a weekend plan focused on couple time but lacked balance with family outings, chores, and rest. Attempts to send the plan to the partner for acceptance failed as no functional send option was found. The acceptance flow could not be verified. Reporting this as a blocking issue and stopping further actions.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=LekZhZDzkE6GjB_ZAAA5' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0j2hbyt&sid=GWRHUulKZyMvIH9sAAAd:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0j98oh4&sid=LekZhZDzkE6GjB_ZAAA5:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302050108281//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.919Z",
    "modified": "2025-09-08T03:27:30.240Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "05383f0c-0138-40d7-8dd6-96c80ac194c0",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC007-Privacy Settings and Data Consent Controls",
    "description": "Verify comprehensive privacy controls, including toggles for per-signal data sharing, data export, deletion, and verifying encrypted storage and on-device processing.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to privacy settings in the app.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the 'Profile' button at index 24 to access privacy settings or find another relevant navigation element.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Settings button (index 1) to access privacy settings.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try clicking the Edit Profile button (index 0) to check if privacy or data controls are accessible there.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Close Edit Profile modal and look for privacy settings or data sharing controls elsewhere on the Profile page or app.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Settings button (index 1) again to check if privacy settings or data sharing controls are accessible now.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Privacy settings or data sharing controls are inaccessible from the Profile page. This is a critical blocking issue preventing verification of privacy controls. Further testing is stopped until this issue is resolved.\nBrowser Console Logs:\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=UIsp4pUV05qdU3mEAAAy' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0itwk9q&sid=UIsp4pUV05qdU3mEAAAy:0:0)\n[WARNING] Warning: Missing `Description` or `aria-describedby={undefined}` for {DialogContent}. (at webpack-internal:///(app-pages-browser)/./node_modules/@radix-ui/react-dialog/dist/index.mjs:476:45)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302067017028//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.924Z",
    "modified": "2025-09-08T03:27:47.170Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "7b8022cb-7cb7-4fd5-9d47-ec07eb0d568d",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC008-AI Load Balancer Fairness and Partner Consent",
    "description": "Validate AI-driven chore load balancer feature distributes tasks fairly between partners and requires explicit partner consent for reassignment.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to the Tasks section to assign chores unevenly between partners.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Tasks' button (index 20) to navigate to the Tasks section.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assign multiple chores unevenly between partners by editing tasks to create imbalance.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/div[3]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Change 'Assigned To' dropdown to 'You' to create uneven chore distribution and save the task.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Invoke the Load Balancer to suggest chore reassignment.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'AI Coach' button (index 22) to invoke the AI-driven load balancer for chore reassignment suggestions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button (index 20) to open additional actions or options that might include the load balancer or chore reassignment feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'AI Coach' button (index 22) to invoke the AI-driven load balancer for chore reassignment suggestions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: Expected result unknown, generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped. The AI-driven chore load balancer feature failed to activate or suggest chore reassignment despite multiple attempts. Multiple chores were assigned unevenly between partners as setup, but the core feature did not respond. Please investigate and fix the issue before retesting.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=xxW2AUp6FLrMDmxbAAAD' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302149225263//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.929Z",
    "modified": "2025-09-08T03:29:09.394Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "87d6da56-5b20-4e98-808d-b6012cb99baf",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC009-Conflict Solver Post-Conflict Summaries",
    "description": "Verify that after a logged conflict event, the Conflict Solver generates accurate, helpful summaries and suggestions for resolution.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Locate and click the interface element to log a conflict event.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to find another interface element or menu option that allows logging a conflict event, possibly by exploring navigation buttons or menus.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Look for an option or button to log a conflict event, possibly under Add Task or other relevant buttons.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Close the 'Add New Task' modal and explore other main navigation tabs or buttons to locate the conflict event logging interface.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Explore other main navigation tabs such as 'Rituals' or 'Goals' to locate the conflict event logging interface.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down to check for any conflict event logging options or buttons, especially the '+' button at index 13 which might allow adding new rituals or events.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click the '+' button at index 15 to check if it allows logging a conflict event.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Daily Sync' button (index 15) to check if it allows logging a conflict event.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Look for an option or button to log a conflict event or add a conflict memory on the Daily Sync page.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Return to Rituals tab and try clicking the '+' button again to explore other menu options like 'Add Memory' or 'AI Coach' for conflict event logging.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Add Memory' button (index 16) to check if it allows logging a conflict event.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '+' button at index 15 to open the menu again and then click 'AI Coach' option to check for conflict resolution features.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Look for an option or button within 'AI Coach' interface to log a conflict event or start conflict resolution.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        assert False, 'Test plan execution failed: expected result unknown, generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Conflict event logging interface or option was not found in the app after thorough exploration of all relevant sections including Rituals, Daily Sync, Add Memory, and AI Coach. Therefore, the verification of Conflict Solver generating summaries and suggestions after a logged conflict event could not be completed.\nBrowser Console Logs:\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=EyqBkKzSAehtIr3bAAAX' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=3aepeWrzvhnhlr5XAAAw' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0iquor6&sid=EyqBkKzSAehtIr3bAAAX:0:0)\n[WARNING] Image with src \"http://localhost:3000/images/couples/romantic-couple-1.svg\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js:15:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302313432235//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.934Z",
    "modified": "2025-09-08T03:31:53.600Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "84ebf9b3-702d-4f7f-b022-e6a5c4509c96",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC010-Gamification Economy: Lakshmi Coins Credit and Debit",
    "description": "Verify that Lakshmi Coins are properly credited and debited according to defined events like quests completion, streak repair, and couple leaderboards.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Complete a Couple Quest or Side Mission to verify Lakshmi Coins credit.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Locate and complete a Couple Quest or Side Mission to verify Lakshmi Coins credit.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Start and complete a Couple Quest or Side Mission by clicking 'Start Task' on a suitable task.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/div[3]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try starting the other available task 'Kids homework help' to see if it triggers task start and Lakshmi Coins credit.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div[2]/div[3]/div[3]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Since the expected result is unknown and the test plan execution has failed, produce a generic failing assertion.\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to start tasks. The 'Start Task' buttons on the Task Management page do not function, preventing completion of Couple Quests or Side Missions and thus blocking verification of Lakshmi Coins credit and debit. Issue reported for resolution.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=a6vqTB3lobH-R_2xAAAm' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=NbAhVwGAGJsC_ZmxAAA9' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/175730195525546//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.940Z",
    "modified": "2025-09-08T03:25:55.406Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "ed1c96db-5e19-4ff7-9b75-90813806455a",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC011-Memory Jukebox and AI Memory Weaver Functionality",
    "description": "Ensure users can capture, save, and resurface joyful contextual memories via the Memory Jukebox and AI Memory Weaver features with proper media handling.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'View Memory Jukebox' button to start capturing a memory.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'View Memory Jukebox' button at index 12 to start capturing a memory.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll or extract content to find the correct interactive element index for the '+' button and click it to start capturing a new memory.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click the '+' button at index 15 to start capturing a new memory (photo, audio, or text).\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Add Memory' button at index 16 to start capturing a new memory (photo, audio, or text).\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Final generic failing assertion since expected result is unknown\n        assert False, 'Test plan execution failed: generic failure assertion appended.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to UI issue: 'Add Memory' button does not open memory capture interface in Memory Jukebox popup. Cannot proceed with capturing memories.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=tNnoYhbgJXDUG4UJAAA7' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=sB7ztyXtRFstnnu9AAAk' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0j9usg2&sid=tNnoYhbgJXDUG4UJAAA7:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0jgfze1&sid=sB7ztyXtRFstnnu9AAAk:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757301956490972//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.945Z",
    "modified": "2025-09-08T03:25:56.628Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "fbef588c-9d6a-4e35-aa7e-b05ac4ff90f1",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC012-Secret Couple Loop Private Intimacy Features",
    "description": "Verify the Secret Couple Loop feature allows private digital intimacy, including nudges and challenges, maintaining strict privacy controls.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to the 'Together' or 'Couple Loop' section to enable Secret Couple Loop feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Next Step' button (index 10) to try to complete Daily Sync step 1 of 2 and unlock further navigation options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Together' button (index 29) to access the Secret Couple Loop feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Home' button (index 9) to explore if the Secret Couple Loop feature is accessible from the Home page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Scroll down to reveal more elements and check if the 'Together' button or Secret Couple Loop feature is accessible further down the page.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click the '+' floating action button (index 19) to check if it opens options for Secret Couple Loop, nudges, or challenges.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Add Memory' button (index 20) to check if it leads to Secret Couple Loop or related private intimacy features like nudges or challenges.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Rituals' button (index 22) to check if the Secret Couple Loop feature or related nudges and challenges are accessible there.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Start Ritual' button (index 12) for the 'Evening Unwind' ritual to check if it leads to Secret Couple Loop or related private intimacy features.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div[2]/div[2]/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Close the ritual modal by clicking the 'Pause' button (index 3) to return to the Rituals page and continue searching for Secret Couple Loop feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Profile' button (index 21) to check for any settings or options to enable or access the Secret Couple Loop feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the 'Settings' button (index 1) to check for any options related to enabling or accessing the Secret Couple Loop feature.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: Secret Couple Loop feature verification failed.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The Secret Couple Loop feature allowing private digital intimacy, including nudges and challenges, could not be located or accessed in the application despite thorough navigation and attempts through Daily Sync, Home, Rituals, Profile, and Settings. No evidence was found to verify its functionality or privacy controls. The task is not fully completed due to the feature's inaccessibility and possible UI issues or missing implementation.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=KggyC3OcbacTuB6DAAAL' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k4c6bkfa&sid=7AXWR2e2YlQ_h_KxAABa:0:0)\n[WARNING] Image with src \"http://localhost:3000/images/couples/romantic-couple-1.svg\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js:15:20)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302373173814//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.950Z",
    "modified": "2025-09-08T03:32:53.358Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "7effda96-0106-46ca-aa74-41e11ea11d15",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC013-Opt-in Ambient Sensing and Contextual AI Nudges",
    "description": "Verify users can opt-in/out of ambient relationship behavior sensing and receive contextual AI nudges that respect privacy, do not trigger intrusive notifications, and adapt to rhythms.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to Profile or Settings to find ambient sensing options to enable calendar, location, and weather signals.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Profile' button (index 24) in the bottom navigation bar to try to access settings for ambient sensing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Settings button (index 1) to open settings and locate ambient sensing options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the Settings button (index 1) to try again to open settings and locate ambient sensing options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to access Settings page from Profile. The Settings button is unresponsive or does not open the settings page, blocking further progress on enabling ambient sensing signals and verifying AI nudges.\nBrowser Console Logs:\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=cWkT747CIwQ-ujZVAAAF' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0i3k5ae&sid=cWkT747CIwQ-ujZVAAAF:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0i4o2dk&sid=Mmk4FL2US2R5oPhmAAAE:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757301988118406//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.956Z",
    "modified": "2025-09-08T03:26:28.243Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "6ad8a52f-e1eb-4a42-945e-6ce604d33048",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC014-Real-Time Communication via Socket.IO",
    "description": "Test real-time updates and communication features implemented with Socket.IO ensuring low latency and correct message delivery.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Open a new tab to log in as the second client (partner) to simulate two clients connected.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open a new tab and log in as second client with provided credentials.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        \n\n        # Input email and password for second client and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('6304132880')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1Snkb@5582')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Clear invalid email input and enter valid email 'priya@example.com' and password 'password123', then click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('priya@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Use 'Demo Login (Arjun & Priya)' button to log in both clients as partners for testing real-time updates.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try 'Skip Sign In (Demo Mode)' button to enter demo mode and simulate two clients connected for real-time update testing.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open a new tab and navigate to the app URL to simulate second client in demo mode.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Open a new tab and navigate to the app URL to simulate second client in demo mode.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Open a new tab to simulate second client session in demo mode and navigate to the app URL.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Open a new tab to simulate second client session in demo mode and navigate to the app URL.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Open a new tab to simulate second client session in demo mode and navigate to the app URL.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Open a new tab or window to simulate second client session in demo mode and navigate to the app URL.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input email 'arjun@example.com' and password 'password123' for first client and click Sign In.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('arjun@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to test real-time updates and communication features with two clients logged in as partners could not be fully completed due to login failures with provided credentials. Demo mode was accessed but did not allow simulating two clients connected simultaneously for real-time communication testing. Therefore, real-time update sending, immediate receipt verification, network interruption simulation, and reconnection state synchronization could not be performed. Further investigation or valid credentials are needed to proceed with full testing.\nBrowser Console Logs:\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=2X3pYgQjqkH4bw8QAAAu' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] [Fast Refresh] performing full reload\n\nFast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\nYou might have a file which exports a React component but also exports a value that is imported by a non-React component file.\nConsider migrating the non-React component export to a separate file and importing it into both files.\n\nIt is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\nFast Refresh requires at least one parent function component in your React tree. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js:111:24)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=4eaZQ4_wuH2TEdGwAABM' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/auth/callback/credentials:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/auth/callback/credentials:0:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=P0vdA03dsI3wl3vwAABi' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k5pas8hq&sid=P0vdA03dsI3wl3vwAABi:0:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=N0iE_5NJejrf5awOAABm' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=cYUeNyNmM3B8mHlmAABn' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k6apboev&sid=cYUeNyNmM3B8mHlmAABn:0:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=QdiVjSlI_prId26LAAB2' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k7gl2w10&sid=BNXoxaqjbQt1qrnBAAB3:0:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302394274043//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.961Z",
    "modified": "2025-09-08T03:33:14.455Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "5de184be-d692-474b-b78f-3891ad6a14b4",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC015-Error Handling for Data Export and Deletion",
    "description": "Test error scenarios during sensitive operations such as data export and deletion, ensure user receives meaningful feedback and system recovers gracefully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Locate and trigger data export to simulate backend failure.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Scroll down or navigate to find data export option to trigger backend failure simulation.\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Click on Profile to access account settings for data export and deletion options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on the 'Settings' button to access data export and deletion options.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[2]/div/div[8]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test failed: generic failure assertion as expected result is unknown.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to access data export and deletion options from the Settings button on the Profile page. The system does not provide the necessary UI elements to trigger error scenarios for these sensitive operations. Please verify the application UI and provide access to these features for further testing.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:3000/api/socketio/?EIO=4&transport=websocket&sid=Ox__LLv3Xts0Gz_GAAAs' failed: WebSocket is closed before the connection is established. (at webpack-internal:///(app-pages-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js:89:0)\n[ERROR] Service worker registration failed TypeError: Failed to register a ServiceWorker for scope ('http://localhost:3000/') with script ('http://localhost:3000/service-worker.js'): ServiceWorker script evaluation failed (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js:56:31)\n[ERROR] Failed to load resource: the server responded with a status of 400 (Bad Request) (at http://localhost:3000/api/socketio/?EIO=4&transport=polling&t=k0irhdzg&sid=PxU01TkvAI7N8NZWAAAa:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757301950874535//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.966Z",
    "modified": "2025-09-08T03:25:51.063Z"
  },
  {
    "projectId": "1bdebe24-ac83-42e7-9050-da24ee7a6b3f",
    "testId": "6b489133-3b1f-48ff-9999-c5e564b32f99",
    "userId": "845854b8-5071-706c-8e7b-5a5f8bead447",
    "title": "TC016-UI Component Rendering and Responsiveness",
    "description": "Verify critical UI components render correctly and maintain responsiveness across different devices and screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        await page.mouse.wheel(0, window.innerHeight)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/div/div/div[3]/div/div[2]/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that primary UI components are visible and interactive on desktop resolution\n        await expect(page.locator('#home-hub')).to_be_visible()\n        await expect(page.locator('#balance-compass')).to_be_visible()\n        await expect(page.locator('#dashboards')).to_be_visible()\n        await expect(page.locator('#home-hub button')).to_be_enabled()\n        await expect(page.locator('#balance-compass button')).to_be_enabled()\n        await expect(page.locator('#dashboards button')).to_be_enabled()\n        # Assert layout is correct by checking bounding boxes do not overlap\n        home_hub_box = await page.locator('#home-hub').bounding_box()\n        balance_compass_box = await page.locator('#balance-compass').bounding_box()\n        dashboards_box = await page.locator('#dashboards').bounding_box()\n        assert home_hub_box is not None and balance_compass_box is not None and dashboards_box is not None\n        assert home_hub_box['x'] + home_hub_box['width'] <= balance_compass_box['x'] or balance_compass_box['x'] + balance_compass_box['width'] <= home_hub_box['x']\n        assert balance_compass_box['x'] + balance_compass_box['width'] <= dashboards_box['x'] or dashboards_box['x'] + dashboards_box['width'] <= balance_compass_box['x']\n        # Simulate mobile portrait orientation and verify UI components render and respond correctly\n        await page.set_viewport_size({'width': 375, 'height': 667})\n        await page.reload()\n        await expect(page.locator('#home-hub')).to_be_visible()\n        await expect(page.locator('#balance-compass')).to_be_visible()\n        await expect(page.locator('#dashboards')).to_be_visible()\n        await expect(page.locator('#home-hub button')).to_be_enabled()\n        await expect(page.locator('#balance-compass button')).to_be_enabled()\n        await expect(page.locator('#dashboards button')).to_be_enabled()\n        # Check layout adaptation by verifying components stack vertically\n        home_hub_box_mobile = await page.locator('#home-hub').bounding_box()\n        balance_compass_box_mobile = await page.locator('#balance-compass').bounding_box()\n        dashboards_box_mobile = await page.locator('#dashboards').bounding_box()\n        assert home_hub_box_mobile is not None and balance_compass_box_mobile is not None and dashboards_box_mobile is not None\n        assert home_hub_box_mobile['y'] + home_hub_box_mobile['height'] <= balance_compass_box_mobile['y'] or balance_compass_box_mobile['y'] + balance_compass_box_mobile['height'] <= home_hub_box_mobile['y']\n        assert balance_compass_box_mobile['y'] + balance_compass_box_mobile['height'] <= dashboards_box_mobile['y'] or dashboards_box_mobile['y'] + dashboards_box_mobile['height'] <= balance_compass_box_mobile['y']\n        # Simulate mobile landscape orientation and verify UI components render and respond correctly\n        await page.set_viewport_size({'width': 667, 'height': 375})\n        await page.reload()\n        await expect(page.locator('#home-hub')).to_be_visible()\n        await expect(page.locator('#balance-compass')).to_be_visible()\n        await expect(page.locator('#dashboards')).to_be_visible()\n        await expect(page.locator('#home-hub button')).to_be_enabled()\n        await expect(page.locator('#balance-compass button')).to_be_enabled()\n        await expect(page.locator('#dashboards button')).to_be_enabled()\n        # Check layout adaptation by verifying components stack horizontally or adapt properly\n        home_hub_box_landscape = await page.locator('#home-hub').bounding_box()\n        balance_compass_box_landscape = await page.locator('#balance-compass').bounding_box()\n        dashboards_box_landscape = await page.locator('#dashboards').bounding_box()\n        assert home_hub_box_landscape is not None and balance_compass_box_landscape is not None and dashboards_box_landscape is not None\n        # They should not overlap horizontally\n        assert home_hub_box_landscape['x'] + home_hub_box_landscape['width'] <= balance_compass_box_landscape['x'] or balance_compass_box_landscape['x'] + balance_compass_box_landscape['width'] <= home_hub_box_landscape['x']\n        assert balance_compass_box_landscape['x'] + balance_compass_box_landscape['width'] <= dashboards_box_landscape['x'] or dashboards_box_landscape['x'] + dashboards_box_landscape['width'] <= balance_compass_box_landscape['x']\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/845854b8-5071-706c-8e7b-5a5f8bead447/1757302395109066//tmp/test_task/result.webm",
    "created": "2025-09-08T03:19:54.988Z",
    "modified": "2025-09-08T03:33:15.305Z"
  }
]
